<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Question Wheel (Display)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body class="disp-body">
  <div class="disp-wrap">
    <div class="watermark" aria-hidden="true"></div>

    <!-- Fullscreen icon (auto-hides; shows near top-right hover/mouse) -->
    <div id="fsZone" class="fs-zone" aria-hidden="false">
      <button id="fsBtn" class="fs-btn" type="button" aria-label="Toggle full screen">
        <span id="fsIcon" class="fs-icon" aria-hidden="true"></span>
      </button>
    </div>

    <div class="wheel-stage">
      <canvas id="wheelCanvas" width="1400" height="1400"></canvas>
      <div class="pointer" aria-hidden="true"></div>
    </div>

    <div class="lower-third" id="lowerThird">
      <div class="lt-label">Question</div>
      <div class="lt-text" id="questionText"></div>
    </div>
  </div>

  <script src="common.js"></script>
  <script src="wheel.js"></script>
  <script>
    const channel = makeWheelChannel();
    const canvas = document.getElementById('wheelCanvas');
    const questionText = document.getElementById('questionText');
    const lowerThird = document.getElementById('lowerThird');

    const wheel = new SienaWheel(canvas, {
      brandText: "",                 // fallback if logo fails to load
      logoSrc: "assets/center-logo.png"
    });

    let currentState = null;
    let orderedQuestions = [];

    function applySync(payload) {
      currentState = payload.state;
      orderedQuestions = Array.isArray(payload.orderedQuestions) ? payload.orderedQuestions : [];
      wheel.setQuestions(orderedQuestions);
    }

    // ---------- Fullscreen (icon button that auto-hides) ----------
    const fsZone = document.getElementById('fsZone');
    const fsBtn = document.getElementById('fsBtn');
    const fsIcon = document.getElementById('fsIcon');

    function isFullscreen() {
      return !!(document.fullscreenElement || document.webkitFullscreenElement);
    }

    function iconArrowsOut() {
      return `
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none"
             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="9 3 3 3 3 9"></polyline>
          <line x1="3" y1="3" x2="10" y2="10"></line>

          <polyline points="15 21 21 21 21 15"></polyline>
          <line x1="14" y1="14" x2="21" y2="21"></line>

          <polyline points="21 9 21 3 15 3"></polyline>
          <line x1="21" y1="3" x2="14" y2="10"></line>

          <polyline points="3 15 3 21 9 21"></polyline>
          <line x1="3" y1="21" x2="10" y2="14"></line>
        </svg>`;
    }

    function iconArrowsIn() {
      return `
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none"
             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="10 3 10 10 3 10"></polyline>
          <polyline points="14 21 14 14 21 14"></polyline>
          <polyline points="21 10 14 10 14 3"></polyline>
          <polyline points="3 14 10 14 10 21"></polyline>
        </svg>`;
    }

    function setFsIcon() {
      fsIcon.innerHTML = isFullscreen() ? iconArrowsIn() : iconArrowsOut();
    }

    async function toggleFullscreen() {
      try {
        if (!isFullscreen()) {
          const el = document.documentElement;
          if (el.requestFullscreen) await el.requestFullscreen();
          else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); // Safari
        } else {
          if (document.exitFullscreen) await document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); // Safari
        }
      } catch (e) {
        // ignore
      }
      setFsIcon();
      showFsZoneTemporarily();
    }

    fsBtn.addEventListener('click', toggleFullscreen);

    document.addEventListener('fullscreenchange', () => {
      setFsIcon();
      showFsZoneTemporarily();
    });
    document.addEventListener('webkitfullscreenchange', () => {
      setFsIcon();
      showFsZoneTemporarily();
    });

    let hideTimer = null;

    function showFsZoneTemporarily() {
      fsZone.classList.add('visible');
      fsZone.classList.remove('hidden');

      if (hideTimer) window.clearTimeout(hideTimer);
      hideTimer = window.setTimeout(() => {
        if (!fsZone.matches(':hover')) {
          fsZone.classList.add('hidden');
          fsZone.classList.remove('visible');
        }
      }, 1500);
    }

    // Show if mouse is near top-right corner
    window.addEventListener('mousemove', (e) => {
      const thresholdX = window.innerWidth - 140;
      const thresholdY = 90;
      if (e.clientX >= thresholdX && e.clientY <= thresholdY) {
        showFsZoneTemporarily();
      }
    });

    // Touch/pointer support (no hover/mousemove on touch devices)
    window.addEventListener('pointerdown', (e) => {
      if (e.pointerType === 'touch') {
        const thresholdX = window.innerWidth - 140;
        const thresholdY = 90;
        if (e.clientX >= thresholdX && e.clientY <= thresholdY) {
          showFsZoneTemporarily();
        }
      }
    });

    fsZone.addEventListener('mouseenter', () => {
      fsZone.classList.add('visible');
      fsZone.classList.remove('hidden');
      if (hideTimer) window.clearTimeout(hideTimer);
    });
    fsZone.addEventListener('mouseleave', () => {
      showFsZoneTemporarily();
    });

    // Optional keyboard shortcut: "f"
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'f') toggleFullscreen();
    });

    setFsIcon();
    showFsZoneTemporarily();

    // ---------- Wheel + lower-third behavior ----------
    channel.onMessage((msg) => {
      if (!msg || typeof msg !== 'object') return;

      if (msg.type === 'sync') {
        applySync(msg.payload || {});
        return;
      }

      if (msg.type === 'spin_to') {
        const { selectedId, orderedIds } = msg.payload || {};
        if (!selectedId) return;

        // Hide lower-third during the spin
        lowerThird.classList.remove('show');
        questionText.textContent = "";

        // Ensure wheel order matches operator
        if (Array.isArray(orderedIds) && currentState && Array.isArray(currentState.questions)) {
          const map = new Map(currentState.questions.map(q => [q.id, q]));
          orderedQuestions = orderedIds.map(id => map.get(id)).filter(Boolean);
          wheel.setQuestions(orderedQuestions);
        }

        const targetIndex = orderedQuestions.findIndex(q => q.id === selectedId);
        if (targetIndex < 0) return;

        // After stop, show the actual question
        wheel.onceStopped((selected) => {
          const text = (selected && selected.text) ? selected.text : (orderedQuestions[targetIndex]?.text || "");
          questionText.textContent = text;
          lowerThird.classList.add('show');
          channel.post({ type: 'spin_complete', payload: { selectedId } });
        });

        wheel.spinToIndex(targetIndex, { minTurns: 5, maxTurns: 8, durationMs: 5200 });
        return;
      }

      if (msg.type === 'operator_ready') {
        channel.post({ type: 'request_sync', payload: {} });
      }
    });

    channel.post({ type: 'display_ready', payload: {} });
    channel.post({ type: 'request_sync', payload: {} });
  </script>
</body>
</html>
