<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Question Wheel (Display)</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body class="disp-body">
  <div class="disp-wrap">
    <div class="watermark" aria-hidden="true"></div>

    <div class="wheel-stage">
      <canvas id="wheelCanvas" width="1400" height="1400"></canvas>
      <div class="pointer" aria-hidden="true"></div>
    </div>

    <div class="lower-third" id="lowerThird">
      <div class="lt-label">Question</div>
      <div class="lt-text" id="questionText"></div>
    </div>
  </div>

  <script src="common.js"></script>
  <script src="wheel.js"></script>
  <script>
    const channel = makeWheelChannel();
    const canvas = document.getElementById('wheelCanvas');
    const questionText = document.getElementById('questionText');
    const lowerThird = document.getElementById('lowerThird');

    const wheel = new SienaWheel(canvas, {
      brandText: "",
      logoSrc: "assets/center-logo.png"
    });

    let currentState = null;
    let orderedQuestions = [];

    function applySync(payload) {
      currentState = payload.state;
      orderedQuestions = Array.isArray(payload.orderedQuestions) ? payload.orderedQuestions : [];
      wheel.setQuestions(orderedQuestions);

      // Keep the lower-third behavior like before:
      // It stays hidden until a spin completes and we have a question to show.
      // (So do NOT add .show here.)
    }

    channel.onMessage((msg) => {
      if (!msg || typeof msg !== 'object') return;

      if (msg.type === 'sync') {
        applySync(msg.payload || {});
        return;
      }

      if (msg.type === 'spin_to') {
        const { selectedId, orderedIds } = msg.payload || {};
        if (!selectedId) return;

        // Hide the lower-third during the spin (same "pop in after stop" behavior)
        lowerThird.classList.remove('show');
        questionText.textContent = "";

        // Ensure wheel order matches operator
        if (Array.isArray(orderedIds) && currentState && Array.isArray(currentState.questions)) {
          const map = new Map(currentState.questions.map(q => [q.id, q]));
          orderedQuestions = orderedIds.map(id => map.get(id)).filter(Boolean);
          wheel.setQuestions(orderedQuestions);
        }

        const targetIndex = orderedQuestions.findIndex(q => q.id === selectedId);
        if (targetIndex < 0) return;

        // Register a guaranteed "after stop" handler for THIS spin
        wheel.onceStopped((selected) => {
          // selected should be the chosen question object
          if (selected && selected.text) {
            questionText.textContent = selected.text;
          } else {
            // fallback if something weird happens
            const fallback = orderedQuestions[targetIndex];
            questionText.textContent = fallback ? fallback.text : "";
          }

          lowerThird.classList.add('show');
          channel.post({ type: 'spin_complete', payload: { selectedId } });
        });

        wheel.spinToIndex(targetIndex, { minTurns: 5, maxTurns: 8, durationMs: 5200 });
        return;
      }

      if (msg.type === 'operator_ready') {
        channel.post({ type: 'request_sync', payload: {} });
      }
    });

    channel.post({ type: 'display_ready', payload: {} });
    channel.post({ type: 'request_sync', payload: {} });
  </script>
</body>
</html>